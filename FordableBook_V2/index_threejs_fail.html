<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Flip Book with Spotlight and Music Control</title>
  <style>
    body,
    html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: black;
      height: 100vh;
    }

    #audio-control {
      position: absolute;
      top: 20px;
      right: 20px;
      background-color: #fff;
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 20px;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.10.4/gsap.min.js"></script>
</head>

<body>
  <!-- 音乐控制按钮 -->
  <button id="audio-control">🔊</button>
  <script>
    let scene, camera, renderer, pages = [], currentPage = 0;
    const images = ["image1.jpg", "image2.jpg", "image3.jpg", "image4.jpg", "image5.jpg", "image6.jpg", "image7.jpg", "image8.jpg"];
    const pageWidth = 2;
    const pageHeight = 3;
    let audio, isPlaying = false;

    function init() {
      // 场景和相机设置
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 0, 8);

      // 渲染器设置，开启阴影
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      // 更强的环境光
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
      scene.add(ambientLight);

      // 聚光灯设置，增加亮度和范围
      const spotlight = new THREE.SpotLight(0xffffff, 1.5);
      spotlight.position.set(0, 5, 5);
      spotlight.castShadow = true;
      spotlight.angle = Math.PI / 6;
      spotlight.penumbra = 0.3;
      spotlight.decay = 2;
      spotlight.distance = 20;
      scene.add(spotlight);

      // 地板，用于显示阴影
      const planeGeometry = new THREE.PlaneGeometry(10, 10);
      const planeMaterial = new THREE.ShadowMaterial({ opacity: 0.2 });
      const plane = new THREE.Mesh(planeGeometry, planeMaterial);
      plane.rotation.x = -Math.PI / 2;
      plane.position.y = -1.5;
      plane.receiveShadow = true;
      scene.add(plane);

      // 创建每一页
      for (let i = 0; i < 4; i++) {
        const frontTexture = new THREE.TextureLoader().load(images[i * 2]);
        const backTexture = new THREE.TextureLoader().load(images[i * 2 + 1]);

        // 增加材质的亮度
        const frontMaterial = new THREE.MeshStandardMaterial({ map: frontTexture, side: THREE.DoubleSide });
        const backMaterial = new THREE.MeshStandardMaterial({ map: backTexture, side: THREE.DoubleSide });

        // 页面几何体
        const geometry = new THREE.PlaneGeometry(pageWidth, pageHeight);
        const page = new THREE.Mesh(geometry, [frontMaterial, backMaterial]);

        // 设置页面阴影和初始位置
        page.castShadow = true;
        page.position.set(i * 0.02, 0, -i * 0.01); // 轻微错位叠加效果
        pages.push(page);
        scene.add(page);
      }

      // 音乐控制
      audio = new Audio('music.mp3');
      document.getElementById('audio-control').addEventListener('click', toggleAudio);

      // 监听点击事件
      document.addEventListener('click', flipPage);
      animate();
    }

    function flipPage() {
      if (currentPage < pages.length) {
        const page = pages[currentPage];
        gsap.to(page.rotation, { y: -Math.PI, duration: 1, ease: "power2.inOut" }); // 使用 gsap 动画库
        currentPage++;
      }
    }

    function toggleAudio() {
      if (isPlaying) {
        audio.pause();
        document.getElementById('audio-control').textContent = '🔈';
      } else {
        audio.play();
        document.getElementById('audio-control').textContent = '🔊';
      }
      isPlaying = !isPlaying;
    }

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    });

    init();
  </script>
</body>

</html>